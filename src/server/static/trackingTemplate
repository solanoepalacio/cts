'use strict'

!(function () {
  // for developers:
  window.alert('hey babe')
  let _ENV = '{{{environment}}}'
  if (_ENV === '{{{environment}}}') {
    _ENV === 'production'
  } 

  const host = '{{{host}}}'
  const scriptId = '{{{scriptId}}}'
  const sessionId = '{{{sessionId}}}'
  const configEvents = '{{{configEvents}}}'
  
  let bounceTimeout = '{{{bounceTimeout}}}' // from config (how much time to consider not bouncing)
  if (bounceTimeout === '{{{bounceTimeout}}}') {
    bounceTimeout = 1 // segs
  }
  
  const session = {
    scriptId: scriptId,
    windowWidth: window.innerWidth,
    windowHeight: window.innerHeight,
    referrer: document.referrer,
    platform: navigator.platform,
    language: navigator.language,
    clicks: [],
    events: [], // TODO: get event names from user config and render them where necessary in the script
    views: [], // paths
    bounced: true
  }

  session.__proto__.addClick = addClickToSession.bind(session)
  
  function addClickToSession (clickEvent) {
    this.clicks.push(
      {
        // what info should be tracked could also be getted from the config
        // note: can we reconstruct the element to show it on cts app?
        url: document.location.href,
        timestamp: Number(Date.now()),
        position: { x: clickEvent.clientX, y: clickEvent.clientY }
        // if more info is needed: ...
      }
    )
  }

  session.__proto__.addView = addViewToSession.bind(session)
  
  function addViewToSession (hashChangeEvent) {
    this.views.push(
      {
        url: document.location.href,
        referrer: document.referrer,
        timestamp: Number(Date.now())
      }
    )
  }

  session.__proto__.addEvent = addEventToSession.bind(session)

  function addEventToSession (event, type, name) {
    // ... TODO: depends on config
  }


  session.__proto__.save = saveSession.bind(session)
  
  function saveSession (fallback) {
    if (!fallback) {
      // fallback is thruthy when navigator.sendBeacon is not present
      // and so the session is saved when it starts and periodically
      this.bounced = false
    } else {
      // keep saving every 120 seconds
      setTimeout(this.save, 120 * 1000)
    }
    let data = Object.assign({}, this)
    // used server-side to calculate the timezone
    data.clientDate = Date.now()
    
    const options = {
      method: 'POST',
      mode: 'cors',
      headers: {
        "Content-Type": 'application/json'
      },
      body: JSON.stringify(data)
    }

    fetch(host + '/public/session/save', options)
    .then((response) => {
      if (_ENV !== 'production') {
        console.log('[session-save] response status:', response.status)
        return response.json()
      }
      return Promise.resolve(false)
    })
    .then((response) => {
      if (response) {
        console.log('[session-save] response:', response)
      }
    })
    .catch((error) => {
      if (_ENV !== 'production') {
        console.log('[session-save] request Error', error)
      }
    })

  }

  session.__proto__.end = endSession.bind(session)
  
  function endSession () {
    this.clientDate = Date.now() // used server-side to calculate timezone
    if (navigator.sendBeacon) {
      let data = '?'
      const dataKeys = Object.keys(this)
      for (let i = 0; i < dataKeys.length; i++) {
        const key = dataKeys[i]
        if (i !== 0) {
          data += '&'
        }
        data += key
        data += '='
        data += typeof this[key] === 'object' ? JSON.stringify(this[key]) : this[key]
      }
      data += '&isBeacon=true'
      navigator.sendBeacon(host + '/public/session/end' + data)
    } else {
      const data = Object.assign({}, this)
      const keys = selectKeys(data)
      const options = {
        method: 'POST',
        mode: 'cors',
        headers: {
          "Content-Type": 'application/json'
        },
        body: JSON.stringify(data, keys)
      }
      // this request might never get to the server.
      fetch(host + 'public/session/end', options)
    }
  }

  if (!navigator.sendBeacon) {
    session.save(true) //  cant be sure if the session will be saved otherwise
  }

  window.setTimeout(session.save, bounceTimeout * 1000)


  window.onunload = () => {
    session.end()
  }

  window.onload = () => {
    session.addView()
    window.addEventListener('click', session.addClick)
  }

  function selectKeys (data) {
    const keys = []
    Object.keys(data).forEach((key) => {
      if (typeof data[key] === 'object' && !Array.isArray(data[key])) {
        const subKeys = selectKeys(data[key])
        keys.concat(subKeys)
        return
      }
      keys.push(key)
    })
    return keys
  }

})()


